// Лабораторная 3, задача 6. Выполнена: Кончик Д. С.

/*
Необходимо приближенно найти корень уравнения f(x) = 0 для функции из своего варианта. 
Корень нужно найти по следующему алгоритму: перебираем значения от начала до конца интервала с некоторым шагом и ищем
значение функции, минимальное по модулю. Аргумент, при котором оно достигается, считаем корнем уравнения. 
Программа должна запросить у пользователя, на сколько частей разделить область поиска корня, 
вычислить шаг, с которым нужно проходить значения, пройти в цикле нужные значения, найти корень и вывести его.

[14 Вариант]: e^sin(x) - sinh(arcsin(x)) - 2, x ∈ [-1; 1]
*/

#include <iostream>
#include <cmath>
using namespace std;

double input_double();

int main()
{

    setlocale(LC_ALL, "Rus");
    double N, solution = 0, f, f_min;

    // Ввод данных
    cout << "Число частей, на которые разбить промежуток [-1; 1]: "; 
    N = input_double();

    // Вычисление корня
    double step = 2 / N; // Шаг переменной 'x'
    f_min = fabs(exp(sin(-1)) - sinh(asin(-1)) - 2); // Модуль значения функции (min)
   
    for (double x = -1; x <= 1; x += step) {

        f = fabs(exp(sin(x)) - sinh(asin(x)) - 2); // Модуль значения функции (текущий)
        
        // Сравнение текущего значения функции с минимальным значением
        if (f < f_min) {
            f_min = f;
            solution = x;
        }
    }

    cout << "Ответ: " << solution;

    return 0;
}

double input_double() {
    double x;

    // Пока не будет введено корректное значение
    while (true) {
        cin >> x;

        // Проверка предыдущего извлечения данных из буфера
        // Извлечение неудачное / удачное, но остались неизвлеченные символы / число отрицательное
        if (cin.fail() || cin.peek() != '\n' || x <= 0) {
            cin.clear(); // Возвращение в обычный режим работы
            cin.ignore(10000, '\n'); // Игнор 'n' символов до Enter
            cout << "Повторите ввод: ";
        }
        else {
            return x;
        }
    }
}