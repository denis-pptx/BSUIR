// Лабораторная 6, задача 8. Выполнена: Кончик Д. С.

/*
У вас есть строка s и фишка, которую вы можете поставить на любой символ этой строки.
После того, как вы поставите фишку, вы можете подвинуть ее вправо несколько (возможно, ноль) раз, 
то есть сделать следующее действие несколько раз: если текущая позиция фишки обозначена как i, 
фишка перемещается в позицию i+1, но действие невозможно, если фишка находится в последней позиции строки.
После того, как вы закончите двигать фишку вправо, вы можете подвинуть ее влево несколько (возможно, ноль) раз, 
то есть сделать следующее действие несколько раз: если текущая позиция фишки обозначена как i, 
фишка перемещается в позицию i−1, но действие невозможно, если фишка находится в первой позиции строки.

Когда вы ставите фишку или перемещаете ее, вы выписываете символ, на котором оказалась фишка. 
Например, если строка s — abcdef, вы ставите фишку на 3-й символ, двигаете ее вправо 2 раза, 
а затем двигаете ее влево 3 раза, вы выпишете строку cdedcb.

Вам даны две строки s и t. Ваше задание — определить, можно ли так выполнить описанные операции со строкой s, 
что в результате вы выпишете строку t.

[Входные данные]
В первой строке задано одно целое число q (1≤q≤500) — количество наборов входных данных.
Каждый набор входных данных состоит из двух строк. В первой строке задана строка s (1≤|s|≤500), 
во второй строке — строка t (1≤|t|≤2⋅|s|−1). Обе строки состоят из строчных букв латинского алфавита.
Гарантируется, что сумма |s| по всем наборам входных данных не превосходит 500.

6
abcdef cdedcb
aaa aaaaa
aab baaa
ab b
abcdef abcdef
ba baa

[Выходные данные]
Для каждого набора выходных данных выведите «YES», если можно выписать строку t, проводя описанные в условии действия со строкой s, или «NO» в противном случае.
Каждую букву можно выводить в любом регистре (YES, yes, Yes будут распознаны как положительный ответ, NO, no и nO будут распознаны как отрицательный ответ).
входные данные выходные данные

YES
YES
NO
YES
YES
NO

*/

#include <iostream>
using namespace std;


int length(char*);
bool chip(char*, char*, int, int);

int main()
{
	int MAX = 500;
	int N; cin >> N;

	// Массивы с входными строками
	char** s = new char* [N];
	char** t = new char* [N];

	// Массив с ответами
	char** ans = new char* [N];

	for (int i = 0; i < N; i++) {
		s[i] = new char[MAX];
		t[i] = new char[MAX];
		ans[i] = new char[3];

		cin >> s[i] >> t[i];

		bool Possibly = false;
		
		// Ставим фишку на каждый символ и проверяем
		for (int j = 0; j < length(s[i]); j++) {

			bool Possibly = chip(s[i], t[i], j, 0);

			if (Possibly) {
				ans[i] = (char*)"YES";
				break;
			}
			else {
				ans[i] = (char*)"NO";
			}
		}
	}

	cout << endl;
	for (int i = 0; i < N; i++)
		cout << ans[i] << endl;
	
	

	return 0;
}


int length(char* str) {
	// Длина строки

	int count = 0;
	while (str[count] != '\0')
		count++;

	return count;
}


bool chip(char* s, char* t, int i, int k) {

	int rep = 0; // Сколько повторилось

	if (s[i] == t[k])
		rep++;
	else
		return false;


	if (i < length(s) && k < length(t)) {
		while (i < length(s) - 1 && k < length(t) - 1 && s[i + 1] == t[k + 1]) { // Вправо
			i++;
			k++;
			rep++;
		}
		while (i > 0 && k < length(t) - 1 && s[i - 1] == t[k + 1]) { // Влево
			i--;
			k++;
			rep++;
		}
	}


	if (rep == length(t))
		return true;
	else
		return false;
}