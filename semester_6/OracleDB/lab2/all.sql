------------
-- TASK 1 --
------------

DROP TABLE groups;
DROP TABLE students;

CREATE TABLE groups (
    id NUMBER,
    name VARCHAR2(100),
    c_val NUMBER
);


CREATE TABLE students (
    id NUMBER,
    name VARCHAR2(100),
    group_id NUMBER
);





------------
-- TASK 2 --
------------

-- Автоинкремент students.id
-- DROP TRIGGER students_ai_id;

CREATE OR REPLACE TRIGGER students_ai_id
BEFORE INSERT ON students
FOR EACH ROW
DECLARE 
    l_max_id NUMBER;
BEGIN
    IF :NEW.ID IS NULL 
    THEN
        SELECT MAX(id) INTO l_max_id FROM students;
        
        IF l_max_id IS NULL 
        THEN
            :NEW.ID := 1;
        ELSE 
            :NEW.ID := l_max_id + 1;
        END IF;
    END IF;
END;
/

-- Уникальность students.id
-- DROP TRIGGER students_unique_id;

CREATE OR REPLACE TRIGGER students_unique_id
FOR INSERT OR UPDATE ON students
FOLLOWS students_ai_id
COMPOUND TRIGGER

    TYPE t_students_id IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    l_students_id t_students_id;

    BEFORE STATEMENT IS
    BEGIN
        l_students_id.DELETE;
    END BEFORE STATEMENT;

    BEFORE EACH ROW IS
    BEGIN
        l_students_id(l_students_id.COUNT + 1) := :NEW.ID;
    END BEFORE EACH ROW;

    AFTER STATEMENT IS
        l_count NUMBER;
        l_id NUMBER;
    BEGIN
        FOR i IN l_students_id.FIRST .. l_students_id.LAST
        LOOP
            l_id := l_students_id(i);
            
            SELECT COUNT(*) INTO l_count FROM students WHERE id = l_id;
            
            IF l_count != 1 THEN
                RAISE_APPLICATION_ERROR(-20000, 'The student id alreasy exists: ' || l_id);
            END IF;
        END LOOP;
    END AFTER STATEMENT;
END students_unique_id;
/

-- Автоинкремент groups.id
-- DROP TRIGGER groups_ai_id;

CREATE OR REPLACE TRIGGER groups_ai_id
BEFORE INSERT ON groups
FOR EACH ROW
DECLARE 
    l_max_id NUMBER;
BEGIN
    IF :NEW.ID IS NULL 
    THEN
        SELECT MAX(id) INTO l_max_id FROM groups;
        
        IF l_max_id IS NULL 
        THEN
            :NEW.ID := 1;
        ELSE 
            :NEW.ID := l_max_id + 1;
        END IF;
    END IF;
END;
/

-- Уникальность groups.id и groups.name
-- DROP TRIGGER groups_unique;

CREATE OR REPLACE TRIGGER groups_unique
FOR INSERT OR UPDATE ON groups
FOLLOWS groups_ai_id
COMPOUND TRIGGER

    TYPE t_groups_id IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    l_groups_id t_groups_id;
    
    TYPE t_groups_name IS TABLE OF VARCHAR(100) INDEX BY PLS_INTEGER;
    l_groups_name t_groups_name;

    BEFORE STATEMENT IS
    BEGIN
        l_groups_id.DELETE;
        l_groups_name.DELETE;
    END BEFORE STATEMENT;

    BEFORE EACH ROW IS
    BEGIN
        l_groups_id(l_groups_id.COUNT + 1) := :NEW.id;
        l_groups_name(l_groups_name.COUNT + 1) := :NEW.name;
    END BEFORE EACH ROW;

    AFTER STATEMENT IS
        l_count NUMBER;
    BEGIN
        FOR i IN l_groups_id.FIRST .. l_groups_id.LAST
        LOOP
            -- check id
            SELECT COUNT(*) INTO l_count FROM groups WHERE id = l_groups_id(i);
            IF l_count != 1 THEN
                RAISE_APPLICATION_ERROR(-20000, 'The group id alreasy exists: ' || l_groups_id(i));
            END IF;
            
            -- check name
            SELECT COUNT(*) INTO l_count FROM groups WHERE name = l_groups_name(i);
            IF l_count != 1 THEN
                RAISE_APPLICATION_ERROR(-20000, 'The group name alreasy exists: ' || l_groups_name(i));
            END IF;
        END LOOP;
    END AFTER STATEMENT;
END groups_unique;
/





------------
-- TASK 3 --
------------

-- Каскадное удаление студентов
-- DROP TRIGGER cascade_students_fk;

CREATE OR REPLACE TRIGGER cascade_students_fk
BEFORE DELETE ON groups
FOR EACH ROW
BEGIN
    DELETE FROM students
    WHERE group_id = :OLD.id;
END;
/

-- Проверка на существование группы
-- DROP TRIGGER students_check_fk;

CREATE OR REPLACE TRIGGER students_check_fk
BEFORE INSERT ON students
FOR EACH ROW
DECLARE
    l_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO l_count FROM groups WHERE id = :NEW.group_id;
    
    IF l_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20000, 'Ошибка: Указанный group_id не существует в таблице groups.');
    END IF;
END;
/





------------
-- TASK 4 --
------------

DROP TABLE log_students;
CREATE TABLE log_students (
    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    action VARCHAR2(10), 
    student_id NUMBER,
    student_name VARCHAR2(100),
    group_id NUMBER, 
    timestamp TIMESTAMP
);

-- DROP TRIGGER log_students_tr;
CREATE OR REPLACE TRIGGER log_students_tr
AFTER INSERT OR UPDATE OR DELETE ON students
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO log_students
        VALUES (NULL, 'INSERT', :NEW.id, :NEW.name, :NEW.group_id, SYSTIMESTAMP);
    ELSIF UPDATING THEN
        INSERT INTO log_students
        VALUES (NULL, 'UPDATE', :NEW.id, :NEW.name, :NEW.group_id, SYSTIMESTAMP);
    ELSIF DELETING THEN
        INSERT INTO log_students
        VALUES (NULL, 'DELETE', :OLD.id, :OLD.name, :OLD.group_id, SYSTIMESTAMP);
    END IF;
END;
/





------------
-- TASK 5 --
------------

-- DROP PROCEDURE restore_students;
CREATE OR REPLACE PROCEDURE restore_students(
    p_timestamp TIMESTAMP DEFAULT NULL,
    p_offset INTERVAL DAY TO SECOND DEFAULT NULL
) 
AS
    l_restore_timestamp TIMESTAMP;
BEGIN
    -- Оба не NULL
    IF (p_timestamp IS NULL) AND (p_offset IS NULL)
    THEN
        RAISE_APPLICATION_ERROR(-20000, 'A timestamp and an offset cant both be empty');
    END IF;

    -- Только один имеет значение
    IF (p_timestamp IS NOT NULL) AND (p_offset IS NULL) THEN
        l_restore_timestamp := p_timestamp;
    ELSIF (p_timestamp IS NULL) AND (p_offset IS NOT NULL) THEN
        l_restore_timestamp := SYSTIMESTAMP - p_offset;
    ELSE
        RAISE_APPLICATION_ERROR(-20000, 'Only either a timestamp or an offset can contain a value.');
    END IF;

    -- Восстановление
    --DELETE FROM students;
    
    FOR log IN (SELECT * FROM log_students WHERE timestamp <= l_restore_timestamp) 
    LOOP
        IF log.ACTION = 'INSERT'
        THEN
            DELETE FROM students
            WHERE id = log.student_id;
            
            INSERT INTO students
            VALUES (log.student_id, log.student_name, log.group_id);
        ELSIF log.ACTION = 'UPDATE'
        THEN
            UPDATE students
            SET NAME = log.student_name, group_id = log.group_id
            WHERE ID = log.student_id;
        ELSIF log.ACTION = 'DELETE' 
        THEN
            DELETE FROM students 
            WHERE ID = log.student_id;
        END IF;
    END LOOP;
END;
/

--EXECUTE restore_students(TO_TIMESTAMP('2024-02-25 22:16:50', 'YYYY-MM-DD HH24:MI:SS'));
--EXECUTE restore_students(p_offset => INTERVAL '0 03:00:00' DAY TO SECOND);



------------
-- TASK 6 --
------------

-- Обновление c_val в group (количество студентов)
-- DROP TRIGGER update_c_val;

CREATE OR REPLACE TRIGGER update_c_val
AFTER INSERT OR UPDATE OR DELETE ON students
FOR EACH ROW
BEGIN 
    
    IF UPDATING THEN
        UPDATE groups
        SET c_val = c_val + 1
        WHERE id = :NEW.group_id;

        UPDATE groups
        SET c_val = c_val - 1
        WHERE id = :OLD.group_id;
    END IF;

    IF INSERTING THEN
        UPDATE groups
        SET c_val = c_val + 1
        WHERE id = :NEW.group_id;
    END IF;

    IF DELETING THEN
        UPDATE groups
        SET c_val = c_val - 1
        WHERE id = :OLD.group_id;
    END IF;
END;
/